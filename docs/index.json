[{"categories":["attacks","kernel"],"content":"fa-solid fa-gear fa-fw fa-sm","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/","tags":["pwn","kernel"],"title":"ğŸªœ Kernel Privesc ğŸªœ","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" OverviewLâ€™objectif de ce post est dâ€™aborder la couche dâ€™abstraction nÃ©cÃ©ssaire Ã  la comprÃ©hension du pwn kernel. Pour cela, il est nÃ©cÃ©ssaire de comprendre comment les diffÃ©rents process interagissent avec le kernel, et comment un contrÃ´le de flow dâ€™execution en kernel-mode peut nous permettre dâ€™amÃ©liorer nos privilÃ¨ges en user-land. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:1:0","tags":["pwn","kernel"],"title":"ğŸªœ Kernel Privesc ğŸªœ","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" Process x KernelIl est important de noter que lâ€™on interagit avec le kernel de pleins de maniÃ¨res diffÃ©rentes. Que ce soit en modifiant le filesystem, avec des syscalls, en communiquant avec des devicesâ€¦ Toutes ces actions nÃ©cÃ©ssitent une intervention du kernel au niveau des process qui les initient. Pour comprendre et manipuler les process, le kernel linux utilise une structure task_struct contenant toutes le informations dont il a besoin : PID, Ã©tat du process, niveau de permissionsâ€¦ Il sauvegarde la task_struct de tous les process en mÃ©moire, sous forme de liste chainÃ©e. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:2:0","tags":["pwn","kernel"],"title":"ğŸªœ Kernel Privesc ğŸªœ","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" PrivescPuisque le kernel peut modifier la structure dâ€™un process, alors il peut modifier les permissions de ce process, et notamment les passer a root. Ainsi, si on trouve une faille niveau kernel qui nous permet de prendre le contrÃ´le du flow dâ€™execution, alors nous pouvons simplement lancer un process en user-land, augmenter ses privileges cÃ´tÃ© kernel et retourner en user-land. Pour faire cela, on va donc modifier la task_struct du process quâ€™on a lancÃ© et changer ses privilÃ¨ges. Comme les privilÃ¨ges dâ€™une task_struct sont, eux aussi, dÃ©finis sous forme de structure, on va faire appel Ã  des fonctions kernel pour modifier proprement la task_struct. /* Process credentials: */ /* Tracer's credentials at attach: */ const struct cred __rcu *ptracer_cred; /* Objective and real subjective task credentials (COW): */ const struct cred __rcu *real_cred; /* Effective (overridable) subjective task credentials (COW): */ const struct cred __rcu *cred; Les fonctions commit_creds() et prepare_kernel_cred() vont nous permettre de faire cela. Pour les appeler correctement, a partir de leur adresse, il faut dâ€™abord les dÃ©finir. unsigned long __attribute__((regparm(3))) (*commit_creds)(unsigned long cred); unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred); void escalate_privs(void){ commit_creds = 0x...; prepare_kernel_cred = 0x...; commit_creds(prepare_kernel_cred(0)); } NB: Il y a plusieurs moyens de trouver les adresses de fonctions kernel. Le plus simple est de lire le fichier /proc/kallsyms qui map les adresses et le symboles kernels. II ne reste donc plus quâ€™Ã  appeler la fonction escalate_privs(). Ce qui nâ€™est possible que si le kernel a des droits dâ€™execution en user-land (pas de SMEP). Sinon il faudra trouver un moyen dÃ©tournÃ© de faire lâ€™appel aux fonctions. Et maintenant le process dÃ©tient des privilÃ¨ges root sur la machine. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:3:0","tags":["pwn","kernel"],"title":"ğŸªœ Kernel Privesc ğŸªœ","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["attacks","kernel"],"content":" TLDRPour simplifier, le but est dâ€™exploiter une vulnerabilitÃ© pour prendre le contrÃ´le du flow dâ€™execution cÃ´tÃ© kernel. Ensuite, on va utiliser les fonctions kernel commit_creds() et prepare_kernel_cred() pour modifier les privilÃ¨ges de notre process. Enfin, on va retourner en user-land pour continuer lâ€™execution de notre process avec les privilÃ¨ges ameliorÃ©s. ","date":"2024-02-19","objectID":"/MyLittlePwney/pwn/kernel/kernel-privesc/:4:0","tags":["pwn","kernel"],"title":"ğŸªœ Kernel Privesc ğŸªœ","uri":"/MyLittlePwney/pwn/kernel/kernel-privesc/"},{"categories":["heap","attacks"],"content":"fa-solid fa-trash-can fa-fw fa-sm","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/","tags":["pwn","heap"],"title":"ğŸ”¥ House of Force ğŸ”¥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" OverviewLâ€™objectif de cette attaque est dâ€™overwrite les metadata du top chunk pour augmenter sa size. Ainsi on va pouvoir faire des malloc sur un espace mÃ©moire beaucoup plus grand et donc malloc en dehors de la HEAP. ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:1:0","tags":["pwn","heap"],"title":"ğŸ”¥ House of Force ğŸ”¥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" DetailDans les versions de la GLIBC \u003c 2.29, il nâ€™y a pas de check sur lâ€™intÃ©gritÃ© des metadata du top chunk. Ainsi, si la size du top chunk est overwrite, lâ€™algorithme malloc fonctionnera quand mÃªme. Comme les chunks sont allouÃ©s Ã  partir du top chunk, si on overwrite la size du top chunk, on devrait Ãªtre en mesure de couvrir lâ€™ensemble des adresses de la mÃ©moire, y compris les addresses en dehors de la heap. Lâ€™intÃ©rÃªt de cette attaque est de pouvoir overwrite des valeurs Ã  des adresses plus basses que lâ€™adresse de la HEAP. Voir de simplement overwrite des valeurs en dehors de la HEAP. ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:2:0","tags":["pwn","heap"],"title":"ğŸ”¥ House of Force ğŸ”¥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" ExploitLâ€™attaque en elle mÃªme se dÃ©roule en 3 Ã©tapes : Overflow notre buffer et overwrite la size du top chunk. On va le set Ã  une valeur suffisamment grande pour que lâ€™adresse ciblÃ©e soit comprise dans la range dâ€™adresses couvertes par le top chunk. On fait un malloc pour placer le dÃ©but du top chunk juste avant lâ€™adresse ciblÃ©e. On effectue un nouveau malloc() qui va nous permettre dâ€™atteindre lâ€™adresse ciblÃ©e. ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:3:0","tags":["pwn","heap"],"title":"ğŸ”¥ House of Force ğŸ”¥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" Further usePour aller plus loin, on peut tenter dâ€™utiliser cette attaque pour obtenir un shell. Pour cela, un stratÃ©gie peut Ãªtre dâ€™overwrite lâ€™adresse du Malloc hook. Ce dernier Ã©tant utilisÃ© Ã  chaque appel de la fonction malloc(), on peut le remplacer par lâ€™adresse de la fonction system() et lui passer une adresse pointant vers un \"/bin/sh\". Ainsi, chaque nouvel appel Ã  la fonction malloc() va hook vers un appel Ã  system(). ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:4:0","tags":["pwn","heap"],"title":"ğŸ”¥ House of Force ğŸ”¥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":["heap","attacks"],"content":" LimitationsA partir de la GLIBC 2.29, la size du top chunk est vÃ©rifiÃ©e pour sâ€™assurer que le top chunk ne sorte pas de sa zone mÃ©moire. GLIBC Top Chunk Size check ","date":"2023-02-20","objectID":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/:5:0","tags":["pwn","heap"],"title":"ğŸ”¥ House of Force ğŸ”¥","uri":"/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/"},{"categories":null,"content":"fcsc ","date":"0001-01-01","objectID":"/MyLittlePwney/writeups/test/:0:0","tags":null,"title":"","uri":"/MyLittlePwney/writeups/test/"}]