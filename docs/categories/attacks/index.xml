<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>attacks - Category - MyLittlePwney</title>
    <link>https://0xeg0.github.io/MyLittlePwney/categories/attacks/</link>
    <description>attacks - Category | MyLittlePwney</description>
    <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 19 Feb 2024 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://0xeg0.github.io/MyLittlePwney/categories/attacks/" rel="self" type="application/rss+xml" /><item>
  <title>ðŸªœ Kernel Privesc ðŸªœ</title>
  <link>https://0xeg0.github.io/MyLittlePwney/pwn/kernel/kernel-privesc/</link>
  <pubDate>Mon, 19 Feb 2024 00:00:00 &#43;0000</pubDate>
  <author>Author</author>
  <guid>https://0xeg0.github.io/MyLittlePwney/pwn/kernel/kernel-privesc/</guid>
  <description><![CDATA[OverviewL&rsquo;objectif de ce post est d&rsquo;aborder la couche d&rsquo;abstraction nÃ©cÃ©ssaire Ã  la comprÃ©hension du pwn kernel. Pour cela, il est nÃ©cÃ©ssaire de comprendre comment les diffÃ©rents process interagissent avec le kernel, et comment un contrÃ´le de flow d&rsquo;execution en kernel-mode peut nous permettre d&rsquo;amÃ©liorer nos privilÃ¨ges en user-land.
Process x KernelIl est important de noter que l&rsquo;on interagit avec le kernel de pleins de maniÃ¨res diffÃ©rentes. Que ce soit en modifiant le filesystem, avec des syscalls, en communiquant avec des devices&hellip; Toutes ces actions nÃ©cÃ©ssitent une intervention du kernel au niveau des process qui les initient.]]></description>
</item>
<item>
  <title>ðŸ”¥ House of Force ðŸ”¥</title>
  <link>https://0xeg0.github.io/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/</link>
  <pubDate>Mon, 20 Feb 2023 00:00:00 &#43;0000</pubDate>
  <author>Author</author>
  <guid>https://0xeg0.github.io/MyLittlePwney/pwn/heap-attacks/attacks/house-of-force/</guid>
  <description><![CDATA[OverviewL&rsquo;objectif de cette attaque est d&rsquo;overwrite les metadata du top chunk pour augmenter sa size. Ainsi on va pouvoir faire des malloc sur un espace mÃ©moire beaucoup plus grand et donc malloc en dehors de la HEAP.
DetailDans les versions de la GLIBC &lt; 2.29, il n&rsquo;y a pas de check sur l&rsquo;intÃ©gritÃ© des metadata du top chunk. Ainsi, si la size du top chunk est overwrite, l&rsquo;algorithme malloc fonctionnera quand mÃªme.]]></description>
</item>
</channel>
</rss>
